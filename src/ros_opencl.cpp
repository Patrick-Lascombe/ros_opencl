#include "ros_opencl/ros_opencl.hpp"

namespace ros_opencl {

    // Private Methods

    void ROS_OpenCL::clean(){
        clReleaseKernel (kernel);
        clReleaseProgram (program);
        clReleaseContext (context);
    }

    std::string ROS_OpenCL::getPlatformName (const cl_platform_id id){
        size_t size = 0;
        clGetPlatformInfo (id, CL_PLATFORM_NAME, 0, NULL, &size);

        std::string result;
        result.resize (size);
        clGetPlatformInfo (id, CL_PLATFORM_NAME, size, const_cast<char*> (result.data ()), NULL);

        return result;
    }

    std::string ROS_OpenCL::getDeviceName (const cl_device_id id){
        size_t size = 0;
        clGetDeviceInfo (id, CL_DEVICE_NAME, 0, NULL, &size);

        std::string result;
        result.resize (size);
        clGetDeviceInfo (id, CL_DEVICE_NAME, size, const_cast<char*> (result.data ()), NULL);

        return result;
    }

    void ROS_OpenCL::checkError (const cl_int error){
        if (error != CL_SUCCESS) {
            std::string error_message = "";

            switch(error){
               case CL_DEVICE_NOT_FOUND:
                    error_message = "CL_DEVICE_NOT_FOUND";
                    break;
               case CL_DEVICE_NOT_AVAILABLE:
                    error_message = "CL_DEVICE_NOT_AVAILABLE";
                    break;
               case CL_COMPILER_NOT_AVAILABLE:
                    error_message = "CL_COMPILER_NOT_AVAILABLE";
                    break;
               case CL_MEM_OBJECT_ALLOCATION_FAILURE:
                    error_message = "CL_MEM_OBJECT_ALLOCATION_FAILURE";
                    break;
               case CL_OUT_OF_RESOURCES:
                    error_message = "CL_OUT_OF_RESOURCES";
                    break;
               case CL_OUT_OF_HOST_MEMORY:
                    error_message = "CL_OUT_OF_HOST_MEMORY";
                    break;
               case CL_PROFILING_INFO_NOT_AVAILABLE:
                    error_message = "CL_PROFILING_INFO_NOT_AVAILABLE";
                    break;
               case CL_MEM_COPY_OVERLAP:
                    error_message = "CL_MEM_COPY_OVERLAP";
                    break;
               case CL_IMAGE_FORMAT_MISMATCH:
                    error_message = "CL_IMAGE_FORMAT_MISMATCH";
                    break;
               case CL_IMAGE_FORMAT_NOT_SUPPORTED:
                    error_message = "CL_IMAGE_FORMAT_NOT_SUPPORTED";
                    break;
               case CL_BUILD_PROGRAM_FAILURE:
                    error_message = "CL_BUILD_PROGRAM_FAILURE";
                    break;
               case CL_MAP_FAILURE:
                    error_message = "CL_MAP_FAILURE";
                    break;
               case CL_MISALIGNED_SUB_BUFFER_OFFSET:
                    error_message = "CL_MISALIGNED_SUB_BUFFER_OFFSET";
                    break;
               case CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST:
                    error_message = "CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST";
                    break;
               case CL_COMPILE_PROGRAM_FAILURE:
                    error_message = "CL_COMPILE_PROGRAM_FAILURE";
                    break;
               case CL_LINKER_NOT_AVAILABLE:
                    error_message = "CL_LINKER_NOT_AVAILABLE";
                    break;
               case CL_LINK_PROGRAM_FAILURE:
                    error_message = "CL_LINK_PROGRAM_FAILURE";
                    break;
               case CL_DEVICE_PARTITION_FAILED:
                    error_message = "CL_DEVICE_PARTITION_FAILED";
                    break;
               case CL_KERNEL_ARG_INFO_NOT_AVAILABLE:
                    error_message = "CL_KERNEL_ARG_INFO_NOT_AVAILABLE";
                    break;
               case CL_INVALID_VALUE:
                    error_message = "CL_INVALID_VALUE";
                    break;
               case CL_INVALID_DEVICE_TYPE:
                    error_message = "CL_INVALID_DEVICE_TYPE";
                    break;
               case CL_INVALID_PLATFORM:
                    error_message = "CL_INVALID_PLATFORM";
                    break;
               case CL_INVALID_DEVICE:
                    error_message = "CL_INVALID_DEVICE";
                    break;
               case CL_INVALID_CONTEXT:
                    error_message = "CL_INVALID_CONTEXT";
                    break;
               case CL_INVALID_QUEUE_PROPERTIES:
                    error_message = "CL_INVALID_QUEUE_PROPERTIES";
                    break;
               case CL_INVALID_COMMAND_QUEUE:
                    error_message = "CL_INVALID_COMMAND_QUEUE";
                    break;
               case CL_INVALID_HOST_PTR:
                    error_message = "CL_INVALID_HOST_PTR";
                    break;
               case CL_INVALID_MEM_OBJECT:
                    error_message = "CL_INVALID_MEM_OBJECT";
                    break;
               case CL_INVALID_IMAGE_FORMAT_DESCRIPTOR:
                    error_message = "CL_INVALID_IMAGE_FORMAT_DESCRIPTOR";
                    break;
               case CL_INVALID_BUILD_OPTIONS:
                    error_message = "CL_INVALID_BUILD_OPTIONS";
                    break;
               case CL_INVALID_PROGRAM:
                    error_message = "CL_INVALID_PROGRAM";
                    break;
               case CL_INVALID_BINARY:
                    error_message = "CL_INVALID_BINARY";
                    break;
               case CL_INVALID_PROGRAM_EXECUTABLE:
                    error_message = "CL_INVALID_PROGRAM_EXECUTABLE";
                    break;
               case CL_INVALID_KERNEL_NAME:
                    error_message = "CL_INVALID_KERNEL_NAME";
                    break;
               case CL_INVALID_KERNEL_DEFINITION:
                    error_message = "CL_INVALID_KERNEL_DEFINITION";
                    break;
               case CL_INVALID_KERNEL:
                    error_message = "CL_INVALID_KERNEL";
                    break;
               case CL_INVALID_ARG_INDEX:
                    error_message = "CL_INVALID_ARG_INDEX";
                    break;
               case CL_INVALID_ARG_VALUE:
                    error_message = "CL_INVALID_ARG_VALUE";
                    break;
               case CL_INVALID_ARG_SIZE:
                    error_message = "CL_INVALID_ARG_SIZE";
                    break;
               case CL_INVALID_KERNEL_ARGS:
                    error_message = "CL_INVALID_KERNEL_ARGS";
                    break;
               case CL_INVALID_WORK_DIMENSION:
                    error_message = "CL_INVALID_WORK_DIMENSION";
                    break;
               case CL_INVALID_WORK_GROUP_SIZE:
                    error_message = "CL_INVALID_WORK_GROUP_SIZE";
                    break;
               case CL_INVALID_WORK_ITEM_SIZE:
                    error_message = "CL_INVALID_WORK_ITEM_SIZE";
                    break;
               case CL_INVALID_GLOBAL_OFFSET:
                    error_message = "CL_INVALID_GLOBAL_OFFSET";
                    break;
               case CL_INVALID_EVENT_WAIT_LIST:
                    error_message = "CL_INVALID_EVENT_WAIT_LIST";
                    break;
               case CL_INVALID_EVENT:
                    error_message = "CL_INVALID_EVENT";
                    break;
               case CL_INVALID_OPERATION:
                    error_message = "CL_INVALID_OPERATION";
                    break;
               case CL_INVALID_GL_OBJECT:
                    error_message = "CL_INVALID_GL_OBJECT";
                    break;
               case CL_INVALID_BUFFER_SIZE:
                    error_message = "CL_INVALID_BUFFER_SIZE";
                    break;
               case CL_INVALID_MIP_LEVEL:
                    error_message = "CL_INVALID_MIP_LEVEL";
                    break;
               case CL_INVALID_GLOBAL_WORK_SIZE:
                    error_message = "CL_INVALID_GLOBAL_WORK_SIZE";
                    break;
               case CL_INVALID_PROPERTY:
                    error_message = "CL_INVALID_PROPERTY";
                    break;
               case CL_INVALID_IMAGE_DESCRIPTOR:
                    error_message = "CL_INVALID_IMAGE_DESCRIPTOR";
                    break;
               case CL_INVALID_COMPILER_OPTIONS:
                    error_message = "CL_INVALID_COMPILER_OPTIONS";
                    break;
               case CL_INVALID_LINKER_OPTIONS:
                    error_message = "CL_INVALID_LINKER_OPTIONS";
                    break;
               case CL_INVALID_DEVICE_PARTITION_COUNT:
                    error_message = "CL_INVALID_DEVICE_PARTITION_COUNT";
                    break;
            }

            ROS_ERROR("OpenCL call failed with error: %d: %s", error, error_message.c_str());
            exit (1);
        }
    }

    std::string ROS_OpenCL::LoadKernel (const char* name){
        std::ifstream in (name);
        std::string result((std::istreambuf_iterator<char>(in)), std::istreambuf_iterator<char>());
        return result;
    }

    cl_program ROS_OpenCL::createProgram (const std::string& source, const cl_context context){
        size_t lengths [1] = { source.size () };
        const char* sources [1] = { source.data () };

        cl_int error = 0;
        cl_program program_ = clCreateProgramWithSource(context, 1, sources, lengths, &error);
        checkError (error);

        return program_;
    }

    // Public Methods

    ROS_OpenCL::ROS_OpenCL(const std::string full_kernel_path, const std::string kernel_function){
        cl_uint platformIdCount = 0;
        clGetPlatformIDs (0, NULL, &platformIdCount);

        if (platformIdCount == 0) {
            ROS_ERROR("No OpenCL platform found");
            exit (1);
        }
        else {
            ROS_INFO("Found %d platform(s)", platformIdCount);
        }

        std::vector<cl_platform_id> platformIds (platformIdCount);
        clGetPlatformIDs (platformIdCount, platformIds.data (), NULL);

        for (cl_uint i = 0; i < platformIdCount; ++i) {
            ROS_INFO("\t (%d) : %s", i+1, getPlatformName (platformIds [i]).c_str());
        }

        cl_uint deviceIdCount = 0;
        clGetDeviceIDs (platformIds [0], CL_DEVICE_TYPE_ALL, 0, NULL, &deviceIdCount);

        if (deviceIdCount == 0) {
            ROS_ERROR("No OpenCL devices found");
            exit (1);
        }
        else {
            ROS_INFO("Found %d device(s)", deviceIdCount);
        }

        deviceIds  = std::vector<cl_device_id>(deviceIdCount);
        clGetDeviceIDs (platformIds [0], CL_DEVICE_TYPE_ALL, deviceIdCount, deviceIds.data(), NULL);

        for (cl_uint i = 0; i < deviceIdCount; ++i) {
            ROS_INFO("\t (%d) : %s", i+1, getDeviceName (deviceIds [i]).c_str());
        }

        const cl_context_properties contextProperties [] = {CL_CONTEXT_PLATFORM, reinterpret_cast<cl_context_properties> (platformIds [0]), 0, 0};

        cl_int error = CL_SUCCESS;
        context = clCreateContext (contextProperties, deviceIdCount, deviceIds.data (), NULL, NULL, &error);
        checkError (error);

        ROS_INFO("Context created");

        program = createProgram (LoadKernel (full_kernel_path.c_str()), context);

        ROS_INFO("Program created");

        checkError (clBuildProgram (program, deviceIdCount, deviceIds.data (), "-D FILTER_SIZE=1", NULL, NULL));

        ROS_INFO("Program built");

        kernel = clCreateKernel (program, kernel_function.c_str(), &error);
        checkError (error);

        ROS_INFO("Kernel created");
    }

    ROS_OpenCL::~ROS_OpenCL(){
        if(!deviceIds.empty()){
            clean();
        }
    }

    ROS_OpenCL ROS_OpenCL::operator=(ROS_OpenCL* s){
        std::swap(kernel, s->kernel);
        std::swap(context, s->context);
        std::swap(program, s->program);
        std::swap(deviceIds, s->deviceIds);
        return *this;
    }

    sensor_msgs::PointCloud2 ROS_OpenCL::process(const sensor_msgs::PointCloud2& msg){
        size_t sz = msg.data.size();
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, sz, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, sz, &msg.data[0], 0, NULL, NULL);
        checkError (error);

        size_t size = sz;

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, 1, NULL, &size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        uint8_t *result = (uint8_t *) malloc(sz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, sz, result, 0, NULL, NULL));

        sensor_msgs::PointCloud2 res = sensor_msgs::PointCloud2(msg);
        res.data.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(sensor_msgs::PointCloud2::Ptr msg){
        size_t sz = msg->data.size();
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, sz, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, sz, &msg->data[0], 0, NULL, NULL);
        checkError (error);

        size_t size = sz;

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, 1, NULL, &size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        uint8_t *result = (uint8_t *) malloc(sz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, sz, result, 0, NULL, NULL));

        msg->data.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseEvent(gpuExec);
        free(result);
    }

    sensor_msgs::LaserScan ROS_OpenCL::process(const sensor_msgs::LaserScan& msg){
        size_t sz = msg.ranges.size();
        cl_int typesz = sizeof(float) * sz;
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &msg.ranges[0], 0, NULL, NULL);
        checkError (error);

        size_t size = sz;

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, 1, NULL, &size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        sensor_msgs::LaserScan res = sensor_msgs::LaserScan(msg);
        res.ranges.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(sensor_msgs::LaserScan::Ptr msg){
        size_t sz = msg->ranges.size();
        cl_int typesz = sizeof(float) * sz;
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &msg->ranges[0], 0, NULL, NULL);
        checkError (error);

        size_t size = sz;

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, 1, NULL, &size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        msg->ranges.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseEvent(gpuExec);
        free(result);
    }

    sensor_msgs::Image ROS_OpenCL::process(const sensor_msgs::Image& msg){
        size_t sz = msg.data.size();
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, sz, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, sz, &msg.data[0], 0, NULL, NULL);
        checkError (error);

        size_t size = sz;

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, 1, NULL, &size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        uint8_t *result = (uint8_t *) malloc(sz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, sz, result, 0, NULL, NULL));

        sensor_msgs::Image res = sensor_msgs::Image(msg);
        res.data.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(sensor_msgs::Image::Ptr msg){
        size_t sz = msg->data.size();
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, sz, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, sz, &msg->data[0], 0, NULL, NULL);
        checkError (error);

        size_t size = sz;

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, 1, NULL, &size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        uint8_t *result = (uint8_t *) malloc(sz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, sz, result, 0, NULL, NULL));

        msg->data.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<float> ROS_OpenCL::process(const std::vector<float> v, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        cl_int typesz = sizeof(float) * sz;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz != 1){
                ROS_WARN("buffers_size includes more elements than needed! Using only the first...");
            }
            typesz = sizeof(float) * params->buffers_size[0];
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);

        size_t size = sz;
        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz != 1){
                ROS_WARN("global_work_size includes more elements than needed! Using only the first...");
            }
            size = params->global_work_size[0];
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, 1, NULL, &size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<float> res = std::vector<float>();

        if (params != NULL and params->buffers_size.size() > 0){
            res.assign(result, result+params->buffers_size[0]);
        }
        else{
            res.assign(result, result+sz);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<float>* v, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        cl_int typesz = sizeof(float) * sz;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz != 1){
                ROS_WARN("buffer_size includes more elements than needed! Using only the first... Using only the first...");
            }
            typesz = sizeof(float) * params->buffers_size[0];
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size = sz;
        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz != 1){
                ROS_WARN("global_work_size includes more elements than needed! Using only the first...");
            }
            size = params->global_work_size[0];
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, 1, NULL, &size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        if (params != NULL and params->buffers_size.size() > 0){
            v->assign(result, result+params->buffers_size[0]);
        }
        else{
            v->assign(result, result+sz);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<double> ROS_OpenCL::process(const std::vector<double> v, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        cl_int typesz = sizeof(double) * sz;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz != 1){
                ROS_WARN("buffer_size includes more elements than needed! Using only the first...");
            }
            typesz = sizeof(float) * params->buffers_size[0];
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);

        size_t size = sz;
        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz != 1){
                ROS_WARN("global_work_size includes more elements than needed! Using only the first...");
            }
            size = params->global_work_size[0];
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, 1, NULL, &size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<double> res = std::vector<double>();

        if (params != NULL and params->buffers_size.size() > 0){
            res.assign(result, result+params->buffers_size[0]);
        }
        else{
            res.assign(result, result+sz);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<double>* v, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        cl_int typesz = sizeof(double) * sz;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz != 1){
                ROS_WARN("buffer_size includes more elements than needed! Using only the first...");
            }
            typesz = sizeof(float) * params->buffers_size[0];
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size = sz;
        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz != 1){
                ROS_WARN("global_work_size includes more elements than needed! Using only the first...");
            }
            size = params->global_work_size[0];
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, 1, NULL, &size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        if (params != NULL and params->buffers_size.size() > 0){
            v->assign(result, result+params->buffers_size[0]);
        }
        else{
            v->assign(result, result+sz);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<int> ROS_OpenCL::process(const std::vector<int> v, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        cl_int typesz = sizeof(int) * sz;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz != 1){
                ROS_WARN("buffer_size includes more elements than needed! Using only the first...");
            }
            typesz = sizeof(float) * params->buffers_size[0];
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);

        size_t size = sz;
        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz != 1){
                ROS_WARN("global_work_size includes more elements than needed! Using only the first...");
            }
            size = params->global_work_size[0];
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, 1, NULL, &size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<int> res = std::vector<int>();

        if (params != NULL and params->buffers_size.size() > 0){
            res.assign(result, result+params->buffers_size[0]);
        }
        else{
            res.assign(result, result+sz);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<int>* v, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        cl_int typesz = sizeof(int) * sz;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz != 1){
                ROS_WARN("buffer_size includes more elements than needed! Using only the first...");
            }
            typesz = sizeof(float) * params->buffers_size[0];
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size = sz;
        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz != 1){
                ROS_WARN("global_work_size includes more elements than needed! Using only the first...");
            }
            size = params->global_work_size[0];
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, 1, NULL, &size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        if (params != NULL and params->buffers_size.size() > 0){
            v->assign(result, result+params->buffers_size[0]);
        }
        else{
            v->assign(result, result+sz);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<char> ROS_OpenCL::process(const std::vector<char> v, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        cl_int typesz = sizeof(char) * sz;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz != 1){
                ROS_WARN("buffer_size includes more elements than needed! Using only the first...");
            }
            typesz = sizeof(float) * params->buffers_size[0];
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);

        size_t size = sz;
        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz != 1){
                ROS_WARN("global_work_size includes more elements than needed! Using only the first...");
            }
            size = params->global_work_size[0];
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, 1, NULL, &size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<char> res = std::vector<char>();

        if (params != NULL and params->buffers_size.size() > 0){
            res.assign(result, result+params->buffers_size[0]);
        }
        else{
            res.assign(result, result+sz);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<char>* v, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        cl_int typesz = sizeof(char) * sz;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz != 1){
                ROS_WARN("buffer_size includes more elements than needed! Using only the first...");
            }
            typesz = sizeof(float) * params->buffers_size[0];
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size = sz;
        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz != 1){
                ROS_WARN("global_work_size includes more elements than needed! Using only the first...");
            }
            size = params->global_work_size[0];
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, 1, NULL, &size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        if (params != NULL and params->buffers_size.size() > 0){
            v->assign(result, result+params->buffers_size[0]);
        }
        else{
            v->assign(result, result+sz);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<char> ROS_OpenCL::process(const std::vector<char> v, const std::vector<char> v2, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<char> res = std::vector<char>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<char>* v, const std::vector<char> v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<char>* v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<char> ROS_OpenCL::process(const std::vector<char> v, const std::vector<int> v2, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<char> res = std::vector<char>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<char>* v, const std::vector<int> v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<int>* v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;
        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        int *result2 = (int *) malloc(typesz2);
        checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

        v2->assign(result2, result2+sz2);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
        free(result2);
    }

    std::vector<char> ROS_OpenCL::process(const std::vector<char> v, const std::vector<float> v2, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<char> res = std::vector<char>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<char>* v, const std::vector<float> v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<float>* v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;
        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        float *result2 = (float *) malloc(typesz2);
        checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

        v2->assign(result2, result2+sz2);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
        free(result2);
    }

    std::vector<char> ROS_OpenCL::process(const std::vector<char> v, const std::vector<double> v2, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<char> res = std::vector<char>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<char>* v, const std::vector<double> v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<double>* v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;
        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        double *result2 = (double *) malloc(typesz2);
        checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

        v2->assign(result2, result2+sz2);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
        free(result2);
    }

    std::vector<int> ROS_OpenCL::process(const std::vector<int> v, const std::vector<char> v2, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<int> res = std::vector<int>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<int>* v, const std::vector<char> v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<char>* v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;
        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        char *result2 = (char *) malloc(typesz2);
        checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

        v2->assign(result2, result2+sz2);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
        free(result2);
    }

    std::vector<int> ROS_OpenCL::process(const std::vector<int> v, const std::vector<int> v2, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<int> res = std::vector<int>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<int>* v, const std::vector<int> v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<int>* v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;
        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<int> ROS_OpenCL::process(const std::vector<int> v, const std::vector<float> v2, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<int> res = std::vector<int>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<int>* v, const std::vector<float> v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<float>* v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;
        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        float *result2 = (float *) malloc(typesz2);
        checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

        v2->assign(result2, result2+sz2);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
        free(result2);
    }

    std::vector<int> ROS_OpenCL::process(const std::vector<int> v, const std::vector<double> v2, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<int> res = std::vector<int>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<int>* v, const std::vector<double> v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<double>* v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;
        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        double *result2 = (double *) malloc(typesz2);
        checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

        v2->assign(result2, result2+sz2);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
        free(result2);
    }

    std::vector<float> ROS_OpenCL::process(const std::vector<float> v, const std::vector<char> v2, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<float> res = std::vector<float>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<float>* v, const std::vector<char> v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<char>* v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;
        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        char *result2 = (char *) malloc(typesz2);
        checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

        v2->assign(result2, result2+sz2);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
        free(result2);
    }

    std::vector<float> ROS_OpenCL::process(const std::vector<float> v, const std::vector<int> v2, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<float> res = std::vector<float>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<float>* v, const std::vector<int> v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<int>* v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;
        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        int *result2 = (int *) malloc(typesz2);
        checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

        v2->assign(result2, result2+sz2);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
        free(result2);
    }

    std::vector<float> ROS_OpenCL::process(const std::vector<float> v, const std::vector<float> v2, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<float> res = std::vector<float>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<float>* v, const std::vector<float> v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<float>* v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;
        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<float> ROS_OpenCL::process(const std::vector<float> v, const std::vector<double> v2, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<float> res = std::vector<float>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<float>* v, const std::vector<double> v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<double>* v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;
        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        double *result2 = (double *) malloc(typesz2);
        checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

        v2->assign(result2, result2+sz2);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
        free(result2);
    }

    std::vector<double> ROS_OpenCL::process(const std::vector<double> v, const std::vector<char> v2, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<double> res = std::vector<double>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<double>* v, const std::vector<char> v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<char>* v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;
        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        char *result2 = (char *) malloc(typesz2);
        checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

        v2->assign(result2, result2+sz2);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
        free(result2);
    }

    std::vector<double> ROS_OpenCL::process(const std::vector<double> v, const std::vector<int> v2, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<double> res = std::vector<double>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<double>* v, const std::vector<int> v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<int>* v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;
        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        int *result2 = (int *) malloc(typesz2);
        checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

        v2->assign(result2, result2+sz2);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
        free(result2);
    }

    std::vector<double> ROS_OpenCL::process(const std::vector<double> v, const std::vector<float> v2, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<double> res = std::vector<double>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<double>* v, const std::vector<float> v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<float>* v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;
        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        float *result2 = (float *) malloc(typesz2);
        checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

        v2->assign(result2, result2+sz2);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
        free(result2);
    }

    std::vector<double> ROS_OpenCL::process(const std::vector<double> v, const std::vector<double> v2, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<double> res = std::vector<double>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<double>* v, const std::vector<double> v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<double>* v2, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 1){
                if (temp_sz > 2){
                    ROS_WARN("buffer_size includes more than two elements. Exactly two are needed. Using the first two...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
            }
            else{
                ROS_WARN("buffer_size includes only one element. Exactly two are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[2] = {sz, sz2};
        size_t work_dimension = 2;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension--;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension--;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                if (temp_sz > 2){
                    ROS_WARN("global_work_size includes more than two elements. A maximum of two is allowed. Using the first two...");
                }
            }
        }

        cl_event gpuExec;
        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseEvent(gpuExec);
        free(result);
    }


    std::vector<char> ROS_OpenCL::process(const std::vector<char> v, const std::vector<char> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<char> res = std::vector<char>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<char>* v, const std::vector<char> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<char>* v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<char>* v2, std::vector<char>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            char *result3;
            result3 = (char *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<char> ROS_OpenCL::process(const std::vector<char> v, const std::vector<char> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<char> res = std::vector<char>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<char>* v, const std::vector<char> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<char>* v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<char>* v2, std::vector<int>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            int *result3;
            result3 = (int *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<char> ROS_OpenCL::process(const std::vector<char> v, const std::vector<char> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<char> res = std::vector<char>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<char>* v, const std::vector<char> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<char>* v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<char>* v2, std::vector<float>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            float *result3;
            result3 = (float *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<char> ROS_OpenCL::process(const std::vector<char> v, const std::vector<char> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<char> res = std::vector<char>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<char>* v, const std::vector<char> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<char>* v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<char>* v2, std::vector<double>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            double *result3;
            result3 = (double *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<char> ROS_OpenCL::process(const std::vector<char> v, const std::vector<int> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<char> res = std::vector<char>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<char>* v, const std::vector<int> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<int>* v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<int>* v2, std::vector<char>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            char *result3;
            result3 = (char *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<char> ROS_OpenCL::process(const std::vector<char> v, const std::vector<int> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<char> res = std::vector<char>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<char>* v, const std::vector<int> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<int>* v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<int>* v2, std::vector<int>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            int *result3;
            result3 = (int *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<char> ROS_OpenCL::process(const std::vector<char> v, const std::vector<int> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<char> res = std::vector<char>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<char>* v, const std::vector<int> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<int>* v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<int>* v2, std::vector<float>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            float *result3;
            result3 = (float *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<char> ROS_OpenCL::process(const std::vector<char> v, const std::vector<int> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<char> res = std::vector<char>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<char>* v, const std::vector<int> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<int>* v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<int>* v2, std::vector<double>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            double *result3;
            result3 = (double *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<char> ROS_OpenCL::process(const std::vector<char> v, const std::vector<float> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<char> res = std::vector<char>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<char>* v, const std::vector<float> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<float>* v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<float>* v2, std::vector<char>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            char *result3;
            result3 = (char *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<char> ROS_OpenCL::process(const std::vector<char> v, const std::vector<float> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<char> res = std::vector<char>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<char>* v, const std::vector<float> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<float>* v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<float>* v2, std::vector<int>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            int *result3;
            result3 = (int *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<char> ROS_OpenCL::process(const std::vector<char> v, const std::vector<float> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<char> res = std::vector<char>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<char>* v, const std::vector<float> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<float>* v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<float>* v2, std::vector<float>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            float *result3;
            result3 = (float *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<char> ROS_OpenCL::process(const std::vector<char> v, const std::vector<float> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<char> res = std::vector<char>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<char>* v, const std::vector<float> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<float>* v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<float>* v2, std::vector<double>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            double *result3;
            result3 = (double *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<char> ROS_OpenCL::process(const std::vector<char> v, const std::vector<double> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<char> res = std::vector<char>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<char>* v, const std::vector<double> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<double>* v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<double>* v2, std::vector<char>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            char *result3;
            result3 = (char *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<char> ROS_OpenCL::process(const std::vector<char> v, const std::vector<double> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<char> res = std::vector<char>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<char>* v, const std::vector<double> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<double>* v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<double>* v2, std::vector<int>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            int *result3;
            result3 = (int *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<char> ROS_OpenCL::process(const std::vector<char> v, const std::vector<double> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<char> res = std::vector<char>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<char>* v, const std::vector<double> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<double>* v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<double>* v2, std::vector<float>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            float *result3;
            result3 = (float *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<char> ROS_OpenCL::process(const std::vector<char> v, const std::vector<double> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<char> res = std::vector<char>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<char>* v, const std::vector<double> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<double>* v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<char>* v, std::vector<double>* v2, std::vector<double>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(char) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(char) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        char *result = (char *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            double *result3;
            result3 = (double *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<int> ROS_OpenCL::process(const std::vector<int> v, const std::vector<char> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<int> res = std::vector<int>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<int>* v, const std::vector<char> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<char>* v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<char>* v2, std::vector<char>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            char *result3;
            result3 = (char *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<int> ROS_OpenCL::process(const std::vector<int> v, const std::vector<char> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<int> res = std::vector<int>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<int>* v, const std::vector<char> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<char>* v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<char>* v2, std::vector<int>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            int *result3;
            result3 = (int *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<int> ROS_OpenCL::process(const std::vector<int> v, const std::vector<char> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<int> res = std::vector<int>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<int>* v, const std::vector<char> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<char>* v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<char>* v2, std::vector<float>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            float *result3;
            result3 = (float *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<int> ROS_OpenCL::process(const std::vector<int> v, const std::vector<char> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<int> res = std::vector<int>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<int>* v, const std::vector<char> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<char>* v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<char>* v2, std::vector<double>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            double *result3;
            result3 = (double *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<int> ROS_OpenCL::process(const std::vector<int> v, const std::vector<int> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<int> res = std::vector<int>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<int>* v, const std::vector<int> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<int>* v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<int>* v2, std::vector<char>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            char *result3;
            result3 = (char *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<int> ROS_OpenCL::process(const std::vector<int> v, const std::vector<int> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<int> res = std::vector<int>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<int>* v, const std::vector<int> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<int>* v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<int>* v2, std::vector<int>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            int *result3;
            result3 = (int *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<int> ROS_OpenCL::process(const std::vector<int> v, const std::vector<int> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<int> res = std::vector<int>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<int>* v, const std::vector<int> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<int>* v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<int>* v2, std::vector<float>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            float *result3;
            result3 = (float *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<int> ROS_OpenCL::process(const std::vector<int> v, const std::vector<int> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<int> res = std::vector<int>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<int>* v, const std::vector<int> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<int>* v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<int>* v2, std::vector<double>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            double *result3;
            result3 = (double *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<int> ROS_OpenCL::process(const std::vector<int> v, const std::vector<float> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<int> res = std::vector<int>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<int>* v, const std::vector<float> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<float>* v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<float>* v2, std::vector<char>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            char *result3;
            result3 = (char *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<int> ROS_OpenCL::process(const std::vector<int> v, const std::vector<float> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<int> res = std::vector<int>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<int>* v, const std::vector<float> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<float>* v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<float>* v2, std::vector<int>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            int *result3;
            result3 = (int *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<int> ROS_OpenCL::process(const std::vector<int> v, const std::vector<float> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<int> res = std::vector<int>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<int>* v, const std::vector<float> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<float>* v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<float>* v2, std::vector<float>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            float *result3;
            result3 = (float *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<int> ROS_OpenCL::process(const std::vector<int> v, const std::vector<float> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<int> res = std::vector<int>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<int>* v, const std::vector<float> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<float>* v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<float>* v2, std::vector<double>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            double *result3;
            result3 = (double *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<int> ROS_OpenCL::process(const std::vector<int> v, const std::vector<double> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<int> res = std::vector<int>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<int>* v, const std::vector<double> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<double>* v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<double>* v2, std::vector<char>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            char *result3;
            result3 = (char *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<int> ROS_OpenCL::process(const std::vector<int> v, const std::vector<double> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<int> res = std::vector<int>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<int>* v, const std::vector<double> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<double>* v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<double>* v2, std::vector<int>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            int *result3;
            result3 = (int *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<int> ROS_OpenCL::process(const std::vector<int> v, const std::vector<double> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<int> res = std::vector<int>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<int>* v, const std::vector<double> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<double>* v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<double>* v2, std::vector<float>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            float *result3;
            result3 = (float *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<int> ROS_OpenCL::process(const std::vector<int> v, const std::vector<double> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<int> res = std::vector<int>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<int>* v, const std::vector<double> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<double>* v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<int>* v, std::vector<double>* v2, std::vector<double>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(int) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(int) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result = (int *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            double *result3;
            result3 = (double *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<float> ROS_OpenCL::process(const std::vector<float> v, const std::vector<char> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<float> res = std::vector<float>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<float>* v, const std::vector<char> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<char>* v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<char>* v2, std::vector<char>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            char *result3;
            result3 = (char *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<float> ROS_OpenCL::process(const std::vector<float> v, const std::vector<char> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<float> res = std::vector<float>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<float>* v, const std::vector<char> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<char>* v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<char>* v2, std::vector<int>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            int *result3;
            result3 = (int *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<float> ROS_OpenCL::process(const std::vector<float> v, const std::vector<char> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<float> res = std::vector<float>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<float>* v, const std::vector<char> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<char>* v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<char>* v2, std::vector<float>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            float *result3;
            result3 = (float *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<float> ROS_OpenCL::process(const std::vector<float> v, const std::vector<char> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<float> res = std::vector<float>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<float>* v, const std::vector<char> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<char>* v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<char>* v2, std::vector<double>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            double *result3;
            result3 = (double *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<float> ROS_OpenCL::process(const std::vector<float> v, const std::vector<int> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<float> res = std::vector<float>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<float>* v, const std::vector<int> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<int>* v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<int>* v2, std::vector<char>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            char *result3;
            result3 = (char *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<float> ROS_OpenCL::process(const std::vector<float> v, const std::vector<int> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<float> res = std::vector<float>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<float>* v, const std::vector<int> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<int>* v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<int>* v2, std::vector<int>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            int *result3;
            result3 = (int *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<float> ROS_OpenCL::process(const std::vector<float> v, const std::vector<int> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<float> res = std::vector<float>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<float>* v, const std::vector<int> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<int>* v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<int>* v2, std::vector<float>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            float *result3;
            result3 = (float *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<float> ROS_OpenCL::process(const std::vector<float> v, const std::vector<int> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<float> res = std::vector<float>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(const std::vector<float> v, const std::vector<float> v2, const std::vector<float> v3, std::vector<float>* v4, const ROS_OpenCL_Params* params) {
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t sz4 = v4->size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t typesz4 = sizeof(float) * sz4;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;

        if (temp_sz > 0){
            if (temp_sz > 3){
                if (temp_sz > 4){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
                typesz4 = sizeof(float) * params->buffers_size[3];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }

        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        cl_mem buffer4 = clCreateBuffer(context, CL_MEM_READ_ONLY, typesz4, NULL, &error);
        checkError(error);

        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        clSetKernelArg (kernel, 3, sizeof (cl_mem), &buffer4);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer4, CL_TRUE, 0, typesz3, &v4->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[4] = {sz, sz2, sz3, sz4};
        size_t work_dimension = 4;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else if (temp_sz == 3){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                work_dimension = 3;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                size[2] = params->global_work_size[3];
                if (temp_sz > 4){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

//        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

//        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz4);
        checkError(clEnqueueReadBuffer(queue, buffer4, CL_TRUE, 0, typesz4, result, 0, NULL, NULL));

        v4->assign(result, result+sz4);


        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseMemObject(buffer4);
        clReleaseEvent(gpuExec);

        free(result);
    }

    void ROS_OpenCL::process(const std::vector<float> vx, const std::vector<float> vy, const std::vector<float> vz, std::vector<float> numDivs, std::vector<float> bounds, std::vector<int>* numPoints, std::vector<int>* firstPoint, std::vector<unsigned int>* indices, float voxelSize, const ROS_OpenCL_Params* params) {
        size_t sz_vx = vx.size();
        size_t sz_vy = vy.size();
        size_t sz_vz = vz.size();
        size_t sz_numDivs = numDivs.size();
        size_t sz_bounds = bounds.size();
        size_t sz_numPoints = numPoints->size();
        size_t sz_firstPoint = firstPoint->size();
        size_t sz_indices = indices->size();
        size_t sz_voxelSize = 1;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;

        size_t typesz_vx = sizeof(float)* sz_vx;
        size_t typesz_vy = sizeof(float)* sz_vy;
        size_t typesz_vz = sizeof(float)* sz_vz;
        size_t typesz_numDivs = sizeof(float)* sz_numDivs;
        size_t typesz_bounds = sizeof(float)* sz_bounds;
        size_t typesz_numPoints = sizeof(int)* sz_numPoints;
        size_t typesz_firstPoint = sizeof(int)* sz_firstPoint;
        size_t typesz_indices = sizeof(unsigned int)* sz_indices;
        size_t typesz_voxelSize = sizeof(float)* sz_voxelSize;

        cl_int error = 0;
        cl_mem buffer_vx = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz_vx, NULL, &error);
        checkError(error);
        cl_mem buffer_vy = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz_vy, NULL, &error);
        checkError(error);
        cl_mem buffer_vz = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz_vz, NULL, &error);
        checkError(error);
        cl_mem buffer_numDivs = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz_numDivs, NULL, &error);
        checkError(error);
        cl_mem buffer_bounds = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz_bounds, NULL, &error);
        checkError(error);
        cl_mem buffer_numPoints = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz_numPoints, NULL, &error);
        checkError(error);
        cl_mem buffer_firstPoint = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz_firstPoint, NULL, &error);
        checkError(error);
        cl_mem buffer_indices = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz_indices, NULL, &error);
        checkError(error);
        cl_mem buffer_voxelSize = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz_voxelSize, NULL, &error);
        checkError(error);


        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer_vx);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer_vy);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer_vz);
        clSetKernelArg (kernel, 3, sizeof (cl_mem), &buffer_numDivs);
        clSetKernelArg (kernel, 4, sizeof (cl_mem), &buffer_bounds);
        clSetKernelArg (kernel, 5, sizeof (cl_mem), &buffer_numPoints);
        clSetKernelArg (kernel, 6, sizeof (cl_mem), &buffer_firstPoint);
        clSetKernelArg (kernel, 7, sizeof (cl_mem), &buffer_indices);
        clSetKernelArg (kernel, 8, sizeof (cl_mem), &buffer_voxelSize);

        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer_vx, CL_TRUE, 0, typesz_vx, &vx[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer_vy, CL_TRUE, 0, typesz_vy, &vy[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer_vz, CL_TRUE, 0, typesz_vz, &vz[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer_numDivs, CL_TRUE, 0, typesz_numDivs, &numDivs[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer_bounds, CL_TRUE, 0, typesz_bounds, &bounds[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer_numPoints, CL_TRUE, 0, typesz_numPoints, &numPoints->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer_firstPoint, CL_TRUE, 0, typesz_firstPoint, &firstPoint->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer_indices, CL_TRUE, 0, typesz_indices, &indices->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer_voxelSize, CL_TRUE, 0, typesz_voxelSize, &voxelSize, 0, NULL, NULL);
        checkError (error);

        size_t size[9] = {sz_vx, sz_vy, sz_vz, sz_numDivs, sz_bounds, sz_numPoints, sz_firstPoint, sz_indices, sz_voxelSize};
        size_t work_dimension = 1;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);


        int *result_numPoints = (int *) malloc(typesz_numPoints);
        int *result_firstPoint = (int *) malloc(typesz_firstPoint);
        unsigned int *result_indices = (unsigned int *) malloc(typesz_indices);

        checkError(clEnqueueReadBuffer(queue, buffer_numPoints, CL_TRUE, 0, typesz_numPoints, result_numPoints, 0, NULL, NULL));
        checkError(clEnqueueReadBuffer(queue, buffer_firstPoint, CL_TRUE, 0, typesz_firstPoint, result_firstPoint, 0, NULL, NULL));
        checkError(clEnqueueReadBuffer(queue, buffer_indices, CL_TRUE, 0, typesz_indices, result_indices, 0, NULL, NULL));

        numPoints->assign(result_numPoints, result_numPoints + sz_numPoints);
        firstPoint->assign(result_firstPoint, result_firstPoint + sz_firstPoint);
        indices->assign(result_indices, result_indices + sz_indices);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer_vx);
        clReleaseMemObject(buffer_vy);
        clReleaseMemObject(buffer_vz);
        clReleaseMemObject(buffer_numDivs);
        clReleaseMemObject(buffer_bounds);
        clReleaseMemObject(buffer_numPoints);
        clReleaseMemObject(buffer_firstPoint);
        clReleaseMemObject(buffer_indices);
        clReleaseMemObject(buffer_voxelSize);
        clReleaseEvent(gpuExec);
        free(result_numPoints);
        free(result_firstPoint);
        free(result_indices);
    }

    void ROS_OpenCL::process(const std::vector<float> vx, const std::vector<float> vy, const std::vector<float> vz, const std::vector<float> minmax, std::vector<int>* isIn, const ROS_OpenCL_Params* params){
        size_t sz_vx = vx.size();
        size_t sz_vy = vy.size();
        size_t sz_vz = vz.size();
        size_t sz_minmax = minmax.size();
        size_t sz_isIn = isIn->size();

        size_t typesz_vx = sizeof(float) * sz_vx;
        size_t typesz_vy = sizeof(float) * sz_vy;
        size_t typesz_vz = sizeof(float) * sz_vz;
        size_t typesz_minmax = sizeof(float) * sz_minmax;
        size_t typesz_isIn = sizeof(int) * sz_isIn;

        cl_int error = 0;
        cl_mem buffer_vx = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz_vx, NULL, &error);
        checkError(error);
        cl_mem buffer_vy = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz_vy, NULL, &error);
        checkError(error);
        cl_mem buffer_vz = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz_vz, NULL, &error);
        checkError(error);
        cl_mem buffer_minmax = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz_minmax, NULL, &error);
        checkError(error);
        cl_mem buffer_isIn = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz_isIn, NULL, &error);
        checkError(error);

        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer_vx);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer_vy);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer_vz);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer_minmax);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer_isIn);

        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer_vx, CL_TRUE, 0, typesz_vx, &vx[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer_vy, CL_TRUE, 0, typesz_vy, &vy[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer_vz, CL_TRUE, 0, typesz_vz, &vz[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer_minmax, CL_TRUE, 0, typesz_minmax, &minmax[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer_isIn, CL_TRUE, 0, typesz_isIn, &isIn[0], 0, NULL, NULL);
        checkError (error);

        size_t size[5] = {sz_vx, sz_vy, sz_vz, sz_minmax, sz_isIn};
        size_t work_dimension = 1;

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        int *result_isIn = (int *) malloc(typesz_isIn);

        checkError(clEnqueueReadBuffer(queue, buffer_isIn, CL_TRUE, 0, typesz_isIn, result_isIn, 0, NULL, NULL));

        isIn->assign(result_isIn, result_isIn + sz_isIn);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer_vx);
        clReleaseMemObject(buffer_vy);
        clReleaseMemObject(buffer_vz);
        clReleaseEvent(gpuExec);
        free(result_isIn);
    }

    void ROS_OpenCL::process(std::vector<float>* v, const std::vector<int> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<int>* v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<int>* v2, std::vector<double>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            double *result3;
            result3 = (double *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<float> ROS_OpenCL::process(const std::vector<float> v, const std::vector<float> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<float> res = std::vector<float>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<float>* v, const std::vector<float> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<float>* v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<float>* v2, std::vector<char>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            char *result3;
            result3 = (char *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<float> ROS_OpenCL::process(const std::vector<float> v, const std::vector<float> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<float> res = std::vector<float>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<float>* v, const std::vector<float> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<float>* v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<float>* v2, std::vector<int>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            int *result3;
            result3 = (int *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<float> ROS_OpenCL::process(const std::vector<float> v, const std::vector<float> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<float> res = std::vector<float>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<float>* v, const std::vector<float> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<float>* v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<float>* v2, std::vector<float>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            float *result3;
            result3 = (float *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<float> ROS_OpenCL::process(const std::vector<float> v, const std::vector<float> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<float> res = std::vector<float>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<float>* v, const std::vector<float> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<float>* v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<float>* v2, std::vector<double>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            double *result3;
            result3 = (double *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<float> ROS_OpenCL::process(const std::vector<float> v, const std::vector<double> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<float> res = std::vector<float>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<float>* v, const std::vector<double> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<double>* v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<double>* v2, std::vector<char>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            char *result3;
            result3 = (char *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<float> ROS_OpenCL::process(const std::vector<float> v, const std::vector<double> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<float> res = std::vector<float>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<float>* v, const std::vector<double> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<double>* v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<double>* v2, std::vector<int>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            int *result3;
            result3 = (int *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<float> ROS_OpenCL::process(const std::vector<float> v, const std::vector<double> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<float> res = std::vector<float>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<float>* v, const std::vector<double> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<double>* v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<double>* v2, std::vector<float>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            float *result3;
            result3 = (float *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<float> ROS_OpenCL::process(const std::vector<float> v, const std::vector<double> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<float> res = std::vector<float>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<float>* v, const std::vector<double> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<double>* v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<float>* v, std::vector<double>* v2, std::vector<double>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(float) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(float) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        float *result = (float *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            double *result3;
            result3 = (double *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<double> ROS_OpenCL::process(const std::vector<double> v, const std::vector<char> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<double> res = std::vector<double>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<double>* v, const std::vector<char> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<char>* v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<char>* v2, std::vector<char>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            char *result3;
            result3 = (char *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<double> ROS_OpenCL::process(const std::vector<double> v, const std::vector<char> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<double> res = std::vector<double>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<double>* v, const std::vector<char> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<char>* v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<char>* v2, std::vector<int>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            int *result3;
            result3 = (int *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<double> ROS_OpenCL::process(const std::vector<double> v, const std::vector<char> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<double> res = std::vector<double>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<double>* v, const std::vector<char> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<char>* v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<char>* v2, std::vector<float>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            float *result3;
            result3 = (float *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<double> ROS_OpenCL::process(const std::vector<double> v, const std::vector<char> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<double> res = std::vector<double>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<double>* v, const std::vector<char> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<char>* v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<char>* v2, std::vector<double>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(char) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(char) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            char *result2;
            result2 = (char *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            double *result3;
            result3 = (double *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<double> ROS_OpenCL::process(const std::vector<double> v, const std::vector<int> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<double> res = std::vector<double>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<double>* v, const std::vector<int> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<int>* v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<int>* v2, std::vector<char>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            char *result3;
            result3 = (char *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<double> ROS_OpenCL::process(const std::vector<double> v, const std::vector<int> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<double> res = std::vector<double>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<double>* v, const std::vector<int> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<int>* v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<int>* v2, std::vector<int>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            int *result3;
            result3 = (int *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<double> ROS_OpenCL::process(const std::vector<double> v, const std::vector<int> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<double> res = std::vector<double>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<double>* v, const std::vector<int> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<int>* v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<int>* v2, std::vector<float>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            float *result3;
            result3 = (float *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<double> ROS_OpenCL::process(const std::vector<double> v, const std::vector<int> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<double> res = std::vector<double>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<double>* v, const std::vector<int> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<int>* v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<int>* v2, std::vector<double>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(int) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(int) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            int *result2;
            result2 = (int *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            double *result3;
            result3 = (double *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<double> ROS_OpenCL::process(const std::vector<double> v, const std::vector<float> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<double> res = std::vector<double>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<double>* v, const std::vector<float> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<float>* v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<float>* v2, std::vector<char>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            char *result3;
            result3 = (char *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<double> ROS_OpenCL::process(const std::vector<double> v, const std::vector<float> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<double> res = std::vector<double>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<double>* v, const std::vector<float> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<float>* v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<float>* v2, std::vector<int>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            int *result3;
            result3 = (int *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<double> ROS_OpenCL::process(const std::vector<double> v, const std::vector<float> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<double> res = std::vector<double>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<double>* v, const std::vector<float> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<float>* v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<float>* v2, std::vector<float>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            float *result3;
            result3 = (float *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<double> ROS_OpenCL::process(const std::vector<double> v, const std::vector<float> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<double> res = std::vector<double>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<double>* v, const std::vector<float> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<float>* v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<float>* v2, std::vector<double>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(float) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(float) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            float *result2;
            result2 = (float *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            double *result3;
            result3 = (double *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<double> ROS_OpenCL::process(const std::vector<double> v, const std::vector<double> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<double> res = std::vector<double>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<double>* v, const std::vector<double> v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<double>* v2, const std::vector<char> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<double>* v2, std::vector<char>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(char) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(char) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            char *result3;
            result3 = (char *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<double> ROS_OpenCL::process(const std::vector<double> v, const std::vector<double> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<double> res = std::vector<double>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<double>* v, const std::vector<double> v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<double>* v2, const std::vector<int> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<double>* v2, std::vector<int>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(int) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(int) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            int *result3;
            result3 = (int *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<double> ROS_OpenCL::process(const std::vector<double> v, const std::vector<double> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<double> res = std::vector<double>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<double>* v, const std::vector<double> v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<double>* v2, const std::vector<float> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<double>* v2, std::vector<float>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(float) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(float) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            float *result3;
            result3 = (float *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    std::vector<double> ROS_OpenCL::process(const std::vector<double> v, const std::vector<double> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v.size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        std::vector<double> res = std::vector<double>();
        res.assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);

        return res;
    }

    void ROS_OpenCL::process(std::vector<double>* v, const std::vector<double> v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2.size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2[0], 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<double>* v2, const std::vector<double> v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3.size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3[0], 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }

    void ROS_OpenCL::process(std::vector<double>* v, std::vector<double>* v2, std::vector<double>* v3, const ROS_OpenCL_Params* params){
        size_t sz = v->size();
        size_t sz2 = v2->size();
        size_t sz3 = v3->size();
        size_t typesz = sizeof(double) * sz;
        size_t typesz2 = sizeof(double) * sz2;
        size_t typesz3 = sizeof(double) * sz3;
        size_t temp_sz = params != NULL ? params->buffers_size.size() : 0;
        if (temp_sz > 0){
            if (temp_sz > 2){
                if (temp_sz > 3){
                    ROS_WARN("buffer_size includes more than three elements. Exactly three are needed. Using the first three...");
                }
                typesz = sizeof(double) * params->buffers_size[0];
                typesz2 = sizeof(double) * params->buffers_size[1];
                typesz3 = sizeof(double) * params->buffers_size[2];
            }
            else{
                ROS_WARN("buffer_size includes less than three elements. Exactly three are needed for custom buffer sizes. Using default values...");
            }
        }
        cl_int error = 0;
        cl_mem buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz, NULL, &error);
        checkError(error);
        cl_mem buffer2 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz2, NULL, &error);
        checkError(error);
        cl_mem buffer3 = clCreateBuffer(context, CL_MEM_READ_WRITE, typesz3, NULL, &error);
        checkError(error);
        clSetKernelArg (kernel, 0, sizeof (cl_mem), &buffer);
        clSetKernelArg (kernel, 1, sizeof (cl_mem), &buffer2);
        clSetKernelArg (kernel, 2, sizeof (cl_mem), &buffer3);
        cl_command_queue queue = clCreateCommandQueueWithProperties (context, deviceIds [0], NULL, &error);

        clEnqueueWriteBuffer(queue, buffer, CL_TRUE, 0, typesz, &v->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer2, CL_TRUE, 0, typesz2, &v2->at(0), 0, NULL, NULL);
        checkError (error);
        clEnqueueWriteBuffer(queue, buffer3, CL_TRUE, 0, typesz3, &v3->at(0), 0, NULL, NULL);
        checkError (error);

        size_t size[3] = {sz, sz2, sz3};
        size_t work_dimension = 3;

        temp_sz = params != NULL ? params->global_work_size.size() : 0;
        if (params == NULL or (params != NULL and not(params->multi_dimensional or temp_sz > 0))){
            work_dimension = 1;
        }
        else if(temp_sz > 0){
            if (params->multi_dimensional){
                ROS_WARN("multi_dimensional should be set to true without pushing to global_work_size. \
                    For default multidimensional global work size, leave the global_work_size vector empty, \
                    and set multi_dimensional to true. Setting the global work size based on the values inside \
                    the global_work_size vector.");
            }
            if (temp_sz == 1){
                size[0] = params->global_work_size[0];
                work_dimension = 1;
            }
            else if (temp_sz == 2){
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                work_dimension = 2;
            }
            else{
                size[0] = params->global_work_size[0];
                size[1] = params->global_work_size[1];
                size[2] = params->global_work_size[2];
                if (temp_sz > 3){
                    ROS_WARN("global_work_size includes more than three elements. A maximum of three is allowed. Using the first three...");
                }
            }
        }

        cl_event gpuExec;

        checkError (clEnqueueNDRangeKernel (queue, kernel, work_dimension, NULL, size, NULL, 0, NULL, &gpuExec));

        clWaitForEvents(1, &gpuExec);

        double *result = (double *) malloc(typesz);
        checkError(clEnqueueReadBuffer(queue, buffer, CL_TRUE, 0, typesz, result, 0, NULL, NULL));

        v->assign(result, result+sz);

        if (typesz2 != typesz or sz != sz2){
            double *result2;
            result2 = (double *) malloc(typesz2);
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result2, 0, NULL, NULL));

            v2->assign(result2, result2+sz2);
            free(result2);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v2->assign(result, result+sz2);
        }

        if (typesz3 != typesz or sz != sz3){
            double *result3;
            result3 = (double *) malloc(typesz3);
            checkError(clEnqueueReadBuffer(queue, buffer3, CL_TRUE, 0, typesz3, result3, 0, NULL, NULL));

            v3->assign(result3, result3+sz3);
            free(result3);
        }
        else{
            checkError(clEnqueueReadBuffer(queue, buffer2, CL_TRUE, 0, typesz2, result, 0, NULL, NULL));

            v3->assign(result, result+sz3);
        }

        clReleaseCommandQueue (queue);
        clReleaseMemObject(buffer);
        clReleaseMemObject(buffer2);
        clReleaseMemObject(buffer3);
        clReleaseEvent(gpuExec);
        free(result);
    }
}
